package org.example;
/*
controller 백엔드와 프론트엔드를 연결하는 로직

@Controller : jsp 나 html 로 작성되어 있는 화면을 소비자에게 보여줄 때 사용
  @GetMapping("소비자가 접속할 주소 경로")
  public String 기능명칭(Model model) {
      model.addAttribute("jsp 화면에서 사용할 변수이름", "jsp 화면에서 사용될 데이터")
      return "jsp 파일 이름"
  }


@RestController : 오직 db 에서 조회된 결과의 데이터만 전달 / html 이나 jsp 파일 XXX
  @GetMapping("소비자가 접속할 주소 경로")
  public String 기능명칭() {
      return "DB 에서 가져온 데이터를 프론트엔드에 전달"
  }

 */
public class Java문법 {
    /*
    접근제한자
    public default protected private

    메서드 = 기능
     1. 생성자
     2. 리턴이 존재하는 기능
     3. 리턴이 존재하지 않는 기능
     4. getter setter
     */
    // 오버라이드 오버라이딩
    // 오버로드(Overload)
    // 같은 이름의 메서드(=기능)을 여러 개 만드는 것
    // 같은 이름을 쓰더라도 매개변수(=파라미터)가 달라야한다.
    /*
    * 매개변수(=파라미터)
    * 매 = 중매   매
    * 개 = 개입할 개
    * 변 = 변할   변
    * 수 = 셀    수
    * 중간에 개입하여 결과를 변경하는 공간의 명칭
    *
    * 변수 = 특정 공간의 명칭으로 내부 데이터는 변할 수 있다.
    * */
    public void 계산기기능(){
        System.out.println("계산을 한다.");
    }
    //              a 와 b에 어떠한 값이 들어가는지에 따라서
    // return 계산기기능이 마지막으로 전달하는 결과가 변경
    public int 계산기기능(int a, int b){
        System.out.println("a와 b의 수를 더한다.");
        return  a+b;
    }



    /* ===================================================== */
    /* =============== 클래스와 인터페이스 차이 =============== */
    /*
    * 1. 클래스
    * 접근제어자 class 파일이름 {
    *      접근제어자 자료형 필드이름 = 변수이름;
    *
    *     접근제어자 void/자료형 기능이름(자료형 매개변수이름) {
    *         // 기능 작성
    *     };
    *    ===> 기능이름() {};  중괄호를 작성하는 것 자체가 기능에 대해 작성한다는 표기
    *         인터페이스에서는 기능이름() 절대로 {} 를 작성해서는 안 됨~!
    *         public 파일이름(){};  --> 메서드 {} 작성한다는 것 자체가 완성된 기능
    * }
    *
    *
    * 2. 인터페이스
    * 접근제어자 interface 파일이름 {
    *      public 자료형 필드이름 = 변수이름;
    *      public void/자료형 기능이름(자료형 매개변수이름);
    * }
    *    ===> 이런 기능이 필요하다 기능에 대한 이름만 선언
    *      public 이외 접근제어자는 불가능
    *     반드시 접근을 해서 기능을 완성해야하기 때문 !!!!!
    *     제발 내게 접근해서 이 기능좀 완성하자
    *
    * */
}
